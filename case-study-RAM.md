#Case-study оптимизации RAM
Актуальная проблема
После первой оптимизации CPU. Удалось агреггировать данные файла с 100 000 строк за менее 30 секунд.
Но была выявленна следующая проблема. Программа потребялем много оперативной памяти. При файле со 100 000 строк данных затрачивается 1292 Mb RAM.
Я решил исправить эту проблему, оптимизировав эту программу.

###Цель
Потребление ОЗУ менее 75Mb при 100 000 строк данных.

###Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я буду вычислять потребление оперативной памяти на тестовом файле в 500 строк.
Для понимая того какая будет асимтотика я собрал общее кол-во потребляемого ОЗУ методов на разном кол-ве строк данных
 



| Кол-во строк  | Byte       | Kb        |    Mb  |
| ------------- |:----------:|:---------:|:------:|
|   **10**      |337856      |329,94     |0,32    |
|   **20**      |337856      |337,70     |0,33    |
|   **30**      |354632      |346,32     |0,34    |
|   **50**      |370176      |361,50     |0,35    |
|   **100**     |411640      |401,99     |0,39    |
|   **500**     |738888      |721,57     |0,70    |
|   **large**  |2564204832  |2504106,28  |2445,42 |
    
![diagram](https://raw.githubusercontent.com/VidgarVii/rails-optimization-2-task2/task-2-optimaiz-ram/benchmarks/RAM/diagram.jpg)

Гарантия корректности работы оптимизированной программы
Написан rspec тест.

###Feedback-Loop

* Профилирование данных по потребелению памяти.
  * Для сбора данных я собрал тестовый файл с данными в 500 строк. 
  * Чтобы в лезть в бюджет на данный должно потратиться не более 200Кб памяти 
* Поиск точки роста
* Оптимизация проблемного кода
* Тестирование профилировщиками результата

Для того, чтобы найти "точки роста" для оптимизации я воспользовался инструментами:
- ruby-prof - Модуль Memory и ALLOCATIONS
- memory_profile

Вот какие проблемы удалось найти и решить

####Ваша находка №1
* Потребление памяти 720,7 Кб *ruby-prof*
![point](https://raw.githubusercontent.com/VidgarVii/rails-optimization-2-task2/task-2-optimaiz-ram/benchmarks/RAM/reports/img/point-1.png)
первая вызвана работай гема MultiJson. Там происходит сериализация данных из хеша в json

Сплит (при 505 вызовов) плодит множества алокаций из-за этого забивается память почти на 20%. 3432(ruby-prof) - 3922(memory_profile)
Уменьшить кол-во алокаций при сплите данных

Я вынес статичные данные в константы. Добавил коммент frozen_string_literal. Разбил метод сплит по условиям

После оптимизации* кода получилось уменьшить кол-во алокаций в общем коде с 15072 до 13595 (memory_profile). 
В методе сплит было не существеное изменение 3376(memory_profile) - 3432(ruby-prof)
Уменьшить кол-во вызовов сплит не удалось.

Общая потребление памяти программы стала 655,125 Кб (- 65,5 Кб) ruby-prof

####Ваша находка №2

Я заметил что сплит формирует лишние данные, которые мне нужны. Я попробую от них избавиться. 

Спустя некоторых манипуляций...

**как изменился отчёт профилировщика**

В худшую сторону. Это был фэйл. Данные стали плодиться как хомяки в брачный период. Вернул всё обратно. 

**Попытка 2**

Обернул в цикл while сбор данных для сессий.

Получилось снизить общее потребление памяти до 598,91 Кб (ruby-prof)

Кол-во алокаций снизилось до 1068332 (memory_profile)

#####Точка роста.
По данным ruby-prof Split спустился на 3 позицию. 
![point](https://raw.githubusercontent.com/VidgarVii/rails-optimization-2-task2/task-2-optimaiz-ram/benchmarks/RAM/reports/img/point-2.png)


memory_profile указывает, что львинная доля памяти уходит на сроки.
Кол-во массивов снизилось с 191640 до 174760
```
allocated memory by class
-----------------------------------
    631093  String
    174760  Array
    143904  File
     56920  Hash

```
  
####Ваша находка №3
Пора заняться Главной точкой роста. MultiJson

Вернул я старый добрый to_json. Запустил rspec. Тесты зеленные. Значит за рамки 30 секунд еще не выпал.

**Кол-во создаваемый алокаций и потребление памяти упало в 2 раза!**


```
Total allocated: 589058 bytes (8071 objects)
Total retained:  117398 bytes (962 objects)
``` 

![point](https://raw.githubusercontent.com/VidgarVii/rails-optimization-2-task2/task-2-optimaiz-ram/benchmarks/RAM/reports/img/point-3.png)

Общее потребление памяти 330.7 Кб.

####Ваша находка №4
C помощью stackprof выявил проблемную зону. Создаётся большое кол-во алокаций. Что так же подтверждает ruby-prof.
```
2954   (36.6%) /  2954  (36.6%)  |    47  |     cols = line.split(SPLIT)
```

Решил по пробовать использовать регекспы не смотря на то, что они медленные. Сами регекспы занес в константу и за фризил. Думал так решу вопрос с созданием лишних алокаций.

**Результат:**
Юзаем valgrind
![point](https://raw.githubusercontent.com/VidgarVii/rails-optimization-2-task2/task-2-optimaiz-ram/benchmarks/RAM/reports/img/point-4.png)
Это фиаско. Откатываемся назад к slip.

memory-profile
```
Total allocated: 1.25 MB (12846 objects)
Total retained:  117.40 kB (962 objects)
```
ruby-prof
```
Fiber ID: 47238691343540
Total: 782872.000000
Sort by: self_time

 %self      total      self      wait     child     calls  name                           location
 19.41  151920.000 151920.000     0.000     0.000      422   String#scan                    
 17.25  202560.000 135040.000     0.000 67520.000     1688   Enumerable#find                
 10.78  84400.000 84400.000     0.000     0.000      844   Regexp#match                   
 10.60  82960.000 82960.000     0.000     0.000     2074   Hash#keys        
```

####Ваша находка №5

На этот раз обратил внимание на сохраненные объекты. В этом помог гем memory_profile.
После ряда рефакторинга. Заменил join на строки. Убрал лишние массивы. 
Так же основной точкой роста был

```
retained objects by location
-----------------------------------
       422  /media/pavel/5404A02704A00DD4/Code/rails-optimization-2-task2/task-2.rb:68

        @report[:usersStats][user][:dates] << data.chomp
```
Bang! методы не всегда являются лучшим результатом. Иногда пладили лишние алокации. Например sort!. Видимо из-за различия входящих данных, данный метод введут себя по разному.

Манипуляции с датой результата не дало. Но как оказалось @result переполнял память. Возможно GC не очищал в нем данные. Так как данные постоянно мутировали и записывались в данную переменную. Стоило данную переменную передавать аргументом и убрать @ потребление памяти уменьшилось до 25Кб

memory_profiler
```
Total allocated: 591.63 kB (8870 objects)
Total retained:  25.19 kB (2 objects)

Retained String Report
-----------------------------------
         1  "Lazaro Raven"
         1  /media/pavel/5404A02704A00DD4/Code/rails-optimization-2-task2/task-2.rb:33

         1  "{\"totalUsers\":78,\"uniqueBrowsersCount\":172,\"totalSessions\":422,\"allBrowsers\":\"CHROME 1,CHROME 10,CHROME 11,CHROME 12,CHROME 13,CHROME 14,CHROME 16,CHROME 17,CHROME 18,CHROME 2,CHROME 20,CHROME 21,CHRO"
         1  /media/pavel/5404A02704A00DD4/Code/rails-optimization-2-task2/task-2.rb:25

``` 

Stackprof 
Не густо информации.
![point](https://raw.githubusercontent.com/VidgarVii/rails-optimization-2-task2/task-2-optimaiz-ram/benchmarks/RAM/reports/img/point-5.png)
![point](https://raw.githubusercontent.com/VidgarVii/rails-optimization-2-task2/task-2-optimaiz-ram/benchmarks/RAM/reports/img/point-6.png)

Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными. Удалось улучшить метрику системы с 2560Mb , до 959 Mb.

Так же выявил, что при работе с сортировкой не всегда хорощо работают bang! методы. 

Прежде чем плодить переменные экземпляра класса хорошенько подумать надо ли он или лучше передавать данные атрибутами метода.
 
while + (shift, delete ...) можеть быть отличным инструментом при работе с большими данными
